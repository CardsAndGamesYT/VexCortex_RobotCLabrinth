#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  D_Sensor_Touch, sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           M_Motor_Left,  tmotorVex393_HBridge, openLoop, reversed, driveLeft, encoderPort, I2C_2)
#pragma config(Motor,  port10,          M_Motor_Right, tmotorVex393_HBridge, openLoop, driveRight, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*+++++++++++++++++++++++++++++++++++++++++++++| Notes |++++++++++++++++++++++++++++++++++++++++++++++
Forward for Distance with IME

Robot Model(s): Modified Squarebot

[I/O Port]          [Name]              [Type]                [Description]
Motor Port 10       rightMotor          393 Motor             Right side motor
Motor Port 1        leftMotor           393 Motor             Left side motor, Reversed
I2C_1               rightIEM            Integrated Encoder    Encoder mounted on rightMotor
I2C_2               leftIEM             Integrated Encoder    Encoted mounted on leftMotor
----------------------------------------------------------------------------------------------------*/

//one tile is about 840 cts
task main()
{
	while(vexRT[Btn8D] == 0)
	{
		motor[M_Motor_Left]	= (vexRT[Ch2] + vexRT[Ch1])/2;
		motor[M_Motor_Right]	= (vexRT[Ch2] - vexRT[Ch1])/2;
	}
//joystick axis 1&2 has controll over the motors untill button 8D is pressed. Then the maze program runs
	if(vexRT[Btn8D]==1)
	{
		wait1Msec(1000);
		resetMotorEncoder(M_Motor_Left);
		resetMotorEncoder(M_Motor_Right);
		while(getMotorEncoder(M_Motor_Left) < 840 * 2) //will decrease the motor thats ahead or set equal if non are ahead
		{
			if(getMotorEncoder(M_Motor_Right) > getMotorEncoder(M_Motor_Left))
			{
				motor(M_Motor_Left) = 63;
				motor(M_Motor_Right) = 40;
			}
			if(getMotorEncoder(M_Motor_Right) < getMotorEncoder(M_Motor_Left))
			{
				motor(M_Motor_Left) = 40;
				motor(M_Motor_Right) = 63;
			}
			if(getMotorEncoder(M_Motor_Right) == getMotorEncoder(M_Motor_Left))
			{
				motor(M_Motor_Left) = 63;
				motor(M_Motor_Right) = 63;
			}
		}
		motor(M_Motor_Left) = 0;
		motor(M_Motor_Right) = 0;
	/*	resetMotorEncoder(M_Motor_Right);
		while(getMotorEncoder(M_Motor_Right) < 840 * 2.5)
		{
			motor(M_Motor_Left) = 10;
			motor(M_Motor_Right) = 110;
		}
		motor(M_Motor_Left) = 0;
		motor(M_Motor_Right) = 0;
		resetMotorEncoder(M_Motor_Left);
		while(getMotorEncoder(M_Motor_Left) < 830 * 3.5)
		{
			if(getMotorEncoder(M_Motor_Right) > getMotorEncoder(M_Motor_Left))
			{
				motor(M_Motor_Left) = 63;
				motor(M_Motor_Right) = 40;
			}
			if(getMotorEncoder(M_Motor_Right) < getMotorEncoder(M_Motor_Left))
			{
				motor(M_Motor_Left) = 40;
				motor(M_Motor_Right) = 63;
			}
			if(getMotorEncoder(M_Motor_Right) == getMotorEncoder(M_Motor_Left))
			{
				motor(M_Motor_Left) = 63;
				motor(M_Motor_Right) = 63;
			}
		} */
	}
}
