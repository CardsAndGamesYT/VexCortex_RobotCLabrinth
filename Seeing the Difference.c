#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  D_Sensor_Touch, sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           M_Motor_Left,  tmotorVex393_HBridge, openLoop, reversed, driveLeft, encoderPort, I2C_2)
#pragma config(Motor,  port10,          M_Motor_Right, tmotorVex393_HBridge, openLoop, driveRight, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*+++++++++++++++++++++++++++++++++++++++++++++| Notes |++++++++++++++++++++++++++++++++++++++++++++++
Forward for Distance with IME

Robot Model(s): Modified Squarebot

[I/O Port]          [Name]              [Type]                [Description]
Motor Port 10       rightMotor          393 Motor             Right side motor
Motor Port 1        leftMotor           393 Motor             Left side motor, Reversed
I2C_1               rightIEM            Integrated Encoder    Encoder mounted on rightMotor
I2C_2               leftIEM             Integrated Encoder    Encoted mounted on leftMotor
----------------------------------------------------------------------------------------------------*/

//one tile is about 840 cts
task main()
{
	while(vexRT[Btn8D] == 0)
	{
		motor[M_Motor_Left]	= (vexRT[Ch2] + vexRT[Ch1])/2;
		motor[M_Motor_Right]	= (vexRT[Ch2] - vexRT[Ch1])/2;
	}
//joystick axis 1&2 has controll over the motors untill button 8D is pressed. Then the maze program runs
	if(vexRT[Btn8D]==1)
	{
		wait1Msec(1000);
		int MotorLeftNorm;
		MotorLeftNorm = 127;
		int MotorRightNorm;
		MotorRightNorm = 127;
		int MotorLeftFast;
		MotorLeftFast = MotorLeftNorm + 10;
		int MotorRightFast;
		MotorRightFast = MotorRightNorm + 10;
		//creates the variables i use for motor power so i dont have to write the numbers 1000000 times when i want to change it
		resetMotorEncoder(M_Motor_Left);
		resetMotorEncoder(M_Motor_Right);
		while(getMotorEncoder(M_Motor_Left) < 840 * 2) //will increase the motor thats behind or set equal if none are behind
		{
			if(getMotorEncoder(M_Motor_Right) > getMotorEncoder(M_Motor_Left))
			{
				motor(M_Motor_Left) = MotorLeftFast;
				motor(M_Motor_Right) = MotorRightNorm;
			}
			if(getMotorEncoder(M_Motor_Left) > getMotorEncoder(M_Motor_Right))
			{
				motor(M_Motor_Left) = MotorLeftNorm;
				motor(M_Motor_Right) = MotorRightFast;
			}
			if(getMotorEncoder(M_Motor_Right) == getMotorEncoder(M_Motor_Left))
			{
				motor(M_Motor_Left) = MotorLeftNorm;
				motor(M_Motor_Right) = MotorRightNorm;
			}
		}
		motor(M_Motor_Left) = 0;
		motor(M_Motor_Right) = 0;
	}
}
