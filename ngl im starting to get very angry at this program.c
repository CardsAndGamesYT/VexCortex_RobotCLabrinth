#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  D_Sensor_Touch, sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           M_Motor_Left,  tmotorVex393_HBridge, PIDControl, reversed, driveLeft, encoderPort, I2C_2)
#pragma config(Motor,  port10,          M_Motor_Right, tmotorVex393_HBridge, PIDControl, driveRight, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*+++++++++++++++++++++++++++++++++++++++++++++| Notes |++++++++++++++++++++++++++++++++++++++++++++++
Forward for Distance with IME

Robot Model(s): Modified Squarebot

[I/O Port]          [Name]              [Type]                [Description]
Motor Port 10       rightMotor          393 Motor             Right side motor
Motor Port 1        leftMotor           393 Motor             Left side motor, Reversed
I2C_1               rightIEM            Integrated Encoder    Encoder mounted on rightMotor
I2C_2               leftIEM             Integrated Encoder    Encoted mounted on leftMotor
----------------------------------------------------------------------------------------------------*/

//one tile is about 840 cts
void DriveStraight(int NormSpeed, int cts);
void TurnMotor(int LeftSpeed, int RightSpeed, int cts, bool bTurnLeft);
//void EnableController(word ButtonPress);
//Above is an unsued function
//this section declairs all functions

task main()
{
//	EnableController(vexRT[Btn8D]);
//joystick axis 1&2 has controll over the motors untill button 8D is pressed. Then the maze program runs - UNUSED
	while(vexRT[Btn8D]==0)
	{}
	if(vexRT[Btn8D]==1) //this cunk waits for controller button 8D to be pressed to beign the labrinth
	{
		wait1Msec(1000);
		DriveStraight(63, 840*1.9);
		TurnMotor(13, 70, 2550, 1);
		DriveStraight(63, 1000);
		//past this point is unfinished and will make the robot go off course
		TurnMotor(70, 13, 1200, 0);
		TurnMotor(30, 20, 3000, 0);
	}
}
//this is the main chunk of code that makes up the labrinth. unfortunatly its only made to compleate the first stright away, first turn, and second straight away. the rest is unfinished and will cause the robot to move in the wrong direction.
//this is simply because i ran out of time to make it run correctly.

void DriveStraight(int NormSpeed, int cts)
{
	resetMotorEncoder(M_Motor_Left);
	resetMotorEncoder(M_Motor_Right);
	moveMotorTarget(M_Motor_Left, cts, NormSpeed, true);
	moveMotorTarget(M_Motor_Right, cts, NormSpeed, true);
	while(getMotorTargetCompleted(M_Motor_Right) == false || getMotorTargetCompleted(M_Motor_Left) == false)
	{
	}
}
//This is a function to make it easier for me to tell the robot to drive stright.
//Rather then re-writing this every time (or copy/pasting it) i can just call `DriveStraight` and define the motor speed and counts to move.
//See examples above in the `Task Main`

void TurnMotor(int LeftSpeed, int RightSpeed, int cts, bool bTurnLeft)
{
	resetMotorEncoder(M_Motor_Left);
	resetMotorEncoder(M_Motor_Right);
	if(TurnLeft == 1)

	{
		moveMotorTarget(M_Motor_Right, cts, RightSpeed, true);
		while(getMotorTargetCompleted(M_Motor_Right) == false)
		{motor(M_Motor_Left) = LeftSpeed;}
	}
	else
	{
		moveMotorTarget(M_Motor_Left, cts, LeftSpeed, true);
		while(getMotorTargetCompleted(M_Motor_Left) == false)
		{motor(M_Motor_Right) = RightSpeed;}
	}
}
//this function is to turn with PID and the `moveMotorTarget` function. depending on if bTurnLeft is 1 or 0 (true or false) the program will decide what motor PID should focus on.
//the reason i make PID ignore one motor is because while turning the motor on the inward side of the turn will NEVER meet the set counts. if PID didnt ignore the one motor, that motor would start moving AFTER the turn was "compleated".
//i use the `motor` function to force PID to ignore the counts on that motor is because all it cares about with the `motor` fuction is making it turn the correct speed.

/*void EnableController(word ButtonPress)
{
	while(vexRT[Btn8D] == ButtonPress)
	{
		motor[M_Motor_Left]	= (vexRT[Ch2] + vexRT[Ch1])/2;
		motor[M_Motor_Right]	= (vexRT[Ch2] - vexRT[Ch1])/2;
	}
}*/

//This is unused code for the old "Controller" function. when i called it, it would enable the controller axis 1&2 to have control over the motors. i had to remove it due to it not wokring properly with PID.
